function [dpred] = run_EM1DFM_fwr(work_dir,meshfile,obsfile,m_con,m_sus,Q)
% Run 1D forward model for all stations inputed in data and store the result in
% model matrix.
% Create a new layer and input files for every inversion
%
% INPUT
% meshfile  : Mesh file in UBC3D format
% obsfile   : Observation file in UBC-EM1DFM format
% conmodel  : Input conductivity model in UBC format (column vector)
% susmodel  : Input susceptitibility model in UBC format (column vector)
% Q         : Querry matrix as generated by "make_EM1DFM_Q_3D.m" function
% mtype     : Inversion type as used be the inversion code EM1DFM
%
% SUB-FUNCTION CALL
% get_UBC_mesh.m    : Load mesh file and output [5xn] matrix
% load_EM1DFM_obs   : Load observation file in UBC-EM1DFM format
% em1dfm.exe        : System call for inversion code
%
% OUTPUT
% pred : predicted data
%   stations. Must be multiplied by P matrix for interpolation everywhere.


%% SCRIPT STARTS HERE

home_dir = pwd;

%% Load 3D mesh
[xn,yn,zn]=read_UBC_mesh([work_dir '\' meshfile]);
nx = length(xn)-1; %size(X,1);    %number of cell in X
ny = length(yn)-1; %size(X,2);    %number of cell in Y
nz = length(zn)-1; %size(X,3);    %number of cell in Z

mcell = nx*ny*nz;

% Create 3D cell center array
% xc = (xn(1:end-1) + xn(2:end) ) /2;
% yc = (yn(1:end-1) + yn(2:end) ) /2;
dz = zn(1:end-1)-zn(2:end);

% Reshape conductivity and susceptibility models
m_con = reshape(m_con,nz,nx,ny);

m_sus = reshape(m_sus,nz,nx,ny);


%% Load observation data file
data = load_EM1DFM_obs(work_dir,obsfile);

% Create observation vectors
[~,index] = unique(data{9}(:,3),'stable');

nsnds = length(index);

% Pre-allocate result
dpred = zeros(nsnds*3,6);
count = 1;
% Cycle through the data and create obsfile, layer file and run inversion
for ii = 1:nsnds
    

    
    logic = (data{9}(:,3) == data{9}(index(ii),3) );%& data{3}(:)==900);
       
    freq    = data{3}(logic);
    tx      = data{1}(logic,:);
    rx      = data{2}(logic,:);
    ontype  = data{4}(logic);
    octype  = data{5}(logic);
    utype   = data{6}(logic);
    obs     = data{7}(logic,:);
    uncert  = data{8}(logic,:);
    X       = data{9}(logic,1);
    Y       = data{9}(logic,2);
    nfreq   = sum(logic);
    
        
    fid = fopen([work_dir '\Obs1D.dat'],'wt');
    fprintf(fid,'%i\n',1);
    
    fprintf(fid, '%f  %f  %i\n', X(1) , Y(1), nfreq); 
             
    for ff = 1 : nfreq
                     
                        
        if tx(ff,5) == 1
            
            ot = 'x';
            
        elseif tx(ff,5) == 2
            
            ot = 'y';
            
        elseif tx(ff,5) == 3
            
            ot = 'z'; 
            
        end
        
        if rx(ff,5) == 1
            
            or = 'x';
            
        elseif rx(ff,5) == 2
            
            or = 'y';
            
        elseif rx(ff,5) == 3
            
            or = 'z'; 
            
        end        
        
            
            argin = 'both';

        
        fprintf(fid, '%i  %i\n', freq(ff), 1);
        fprintf(fid, '%f  %f  %s  %i\n', tx(ff,4), tx(ff,3), ot, 1);
                
        if strcmp(octype{ff},'b')==1

            switch argin

                case 'inphase'

                    fprintf(fid, '%f  %f  %f  %f  %s  %i  %s \n',...
                    rx(ff,4), tx(ff,1), tx(ff,2),...
                    rx(ff,3) ,or, ontype(ff), 'i');


                case 'quad'

                    fprintf(fid, '%f  %f  %f  %f  %s  %i  %s \n',...
                    rx(ff,4), tx(ff,1), tx(ff,2),...
                    rx(ff,3) ,or, ontype(ff), 'q');

                case 'both'

                    fprintf(fid, '%f  %f  %f  %f  %s  %i  %s \n',...
                            rx(ff,4), tx(ff,1), tx(ff,2),...
                            rx(ff,3) ,or, ontype(ff), octype{ff});

                otherwise

                    fprintf('Input argument should be inphase, quad or both\n');
                    break

            end

        else

            fprintf(fid, '%f  %f  %f  %f  %s  %i  %s  %12.4e  %s  %12.4e  \n',...
                    rx(ff,4), tx(ff,1), tx(ff,2),...
                    rx(ff,3) ,or, ontype(ff), octype{ff},...
                    obs(ff,1),utype{ff},uncert(ff,1));

        end
           
        
        
    end
    
    fclose(fid);
    
    % Create layer conductivity, susc and weights
    
    dz_layer = dz(Q(ii,3):end)';
    cond = m_con(Q(ii,3):end,Q(ii,1),Q(ii,2));
    
    susc = m_sus(Q(ii,3):end,Q(ii,1),Q(ii,2));
        
    ncells = length(dz_layer);
    
    % Check if phid has reached misfit, keep beta the same
    
    
    fid1 = fopen([work_dir '\EM1D_con.dat'],'wt');
    fprintf(fid1,'%i\n',ncells+1);
    
    fid3 = fopen([work_dir '\EM1D_sus.dat'],'wt');
    fprintf(fid3,'%i\n',ncells+1);
    
    
    for jj = 1 : ncells
        
    % First iteration uses best halfspace


        fprintf(fid1,'%12.4f%12.4e\t\n',dz_layer(jj),cond(jj));
            
        
        fprintf(fid3,'%12.4f\t%12.8e\n',dz_layer(jj),susc(jj));

    end
    

    fprintf(fid1,'%12.4f\t%12.4e\n',0.0,cond(jj));

    fprintf(fid3,'%12.4f\t%12.8e\n',0.0,0);

    fclose('all');
    %% Write input file
    fid = fopen([work_dir '\em1dfmfwd.in'],'wt');
    
    fprintf(fid,'Obs1D.dat  ! obs file name\n');
    fprintf(fid,'EM1D_con.dat  ! ref (small) model\n');
    fprintf(fid,'EM1D_sus.dat  ! ref (small) model\n');
    fprintf(fid,'100 ! number of Hankel kernel\n');
    fprintf(fid,'n  ! no noise added\n');
    
    fclose(fid);
    
    %% Run inversion and load model 
    cd(work_dir);

    system('em1dfmfwd');

    cd(home_dir);

    
    
    % Load predicted and store
    d_pred = load_EM1DFM_obs(work_dir,'em1dfmfwd.out');
    
    dpred(count:count+2,:) = [d_pred{9}(:,1:2) d_pred{2}(:,3) d_pred{3}(:,1) d_pred{7}(:,:)];
    
    count = count + 3;
    
    fprintf(['Stn : ' num2str(ii) ' of ' num2str(nsnds) '\n'])
    
end





