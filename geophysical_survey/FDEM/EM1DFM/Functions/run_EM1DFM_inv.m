function [m_con1D,m_sus1D,m_misfit,phid,phim,beta,d_pred,bHSpace] = run_EM1DFM_inv(work_dir,meshfile,data,m_con,m_con_ref,m_sus,m_sus_ref,alpha_con,alpha_sus,w,Q,mtype,niter,phid,beta,cooling,target,argin,iter,pred_in,xyz,HSflag)
% Run 1D inversion for all stations     [m_con1D,m_sus1D,m_misfit,phid,phim,beta,pred,bHSpace] = run_EM1DFM_inv(work_dir,meshfile,data,m_con,con_ref,m_sus,sus_ref,alpha,w,Q,mtype,1,phid,beta,cooling,target,'both',ii,pred(:,5:6),xyz);
% model matrix.
% Create a new layer and input files for every inversion
%
% INPUT
% meshfile  : Mesh file in UBC3D format
% obsfile   : Observation file in UBC-EM1DFM format
% conmodel  : Input conductivity model in UBC format (column vector)
% susmodel  : Input susceptitibility model in UBC format (column vector)
% Q         : Querry matrix as generated by "make_EM1DFM_Q_3D.m" function
% mtype     : Inversion type as used be the inversion code EM1DFM
%
% SUB-FUNCTION CALL
% get_UBC_mesh.m    : Load mesh file and output [5xn] matrix
% load_EM1DFM_obs   : Load observation file in UBC-EM1DFM format
% em1dfm.exe        : System call for inversion code
%
% OUTPUT
% m_inv3D : 3D model with columns of inverted model at the location of
%   stations. Must be multiplied by P matrix for interpolation everywhere.

%% FOR DEV ONLY
% clear all
% close all
% 
% work_dir     = 'C:\Users\dominiquef\Dropbox\DIGHEM\Processed_data\1DEMInversions\ALL_DF';
% load([work_dir '\Q']);
% load([work_dir '\nullcell.dat']);
% mtype = 1;
% meshfile    = 'UBC_mesh.msh';
% obsfile = 'DIGHEM_TKC_ALL.obs';
% 
% % Create inform background models for now
% conmodel = nullcell; conmodel(conmodel==1) = 1e-4;
% conmodel(conmodel==0) = 1e-8;
% 
% susmodel = nullcell; susmodel(susmodel==1) = 0;

%% SCRIPT STARTS HERE

home_dir = pwd;

%% Load 3D mesh
[xn,yn,zn]=read_UBC_mesh([work_dir '\' meshfile]);
nx = length(xn)-1; %size(X,1);    %number of cell in X
ny = length(yn)-1; %size(X,2);    %number of cell in Y
nz = length(zn)-1; %size(X,3);    %number of cell in Z

mcell = nx*ny*nz;

% Create 3D cell center array
% xc = (xn(1:end-1) + xn(2:end) ) /2;
% yc = (yn(1:end-1) + yn(2:end) ) /2;
dz = zn(1:end-1)-zn(2:end);

% Reshape conductivity and susceptibility models
m_con = reshape(m_con,nz,nx,ny);
m_con_ref = reshape(m_con_ref,nz,nx,ny);
m_sus = reshape(m_sus,nz,nx,ny);
m_sus_ref = reshape(m_sus_ref,nz,nx,ny);
w = reshape(w,nz,nx,ny);

% Change work_dir to workspace
work_dir = [work_dir '\Workspace'];
mkdir(work_dir);

%% Load observation data file
% data = load_EM1DFM_obs(work_dir,obsfile);
d_pred = [];

% Create observation vectors
[ll,index] = unique(data{9}(:,3));

nstn = length(index);

% Create final 1D model result matrix. At most nz cells from 3D mesh
m_con1D = ones(nz,nx,ny)*1e-8;
m_sus1D = zeros(nz,nx,ny);
m_misfit = ones(nz,nx,ny)*1e-8;
bHSpace     = ones(nz,nx,ny)*1e-8;

% Pre-allocate results
itern   = zeros(nstn,1);
phim    = zeros(nstn,1);
phi     = zeros(nstn,1);


% Cycle through the data and create obsfile, layer file and run inversion
for ii = 1:nstn
    

    
    logic = (data{9}(:,3) == data{9}(index(ii),3) );%& data{3}(:)==900);
       
    nfreq   = sum(logic);
    freq    = data{3}(logic);
    tx      = data{1}(logic,:);
    rx      = data{2}(logic,:);
    ontype  = data{4}(logic);
    octype  = data{5}(logic);
    utype   = data{6}(logic);
    obs     = data{7}(logic,:);
    pre     = pred_in(logic,:);
    uncert  = data{8}(logic,:);
    X       = kron( ones(nfreq,1) , xyz(ii,1) );
    Y       = kron( ones(nfreq,1) , xyz(ii,2) );
    Z       = kron( ones(nfreq,1) , xyz(ii,3) );
    
    
        
    fid = fopen([work_dir '\Obs1D.dat'],'wt');
    fprintf(fid,'%i\n',1);
    
%     if ii == 598
%         
%         aa =1;
%         
%     end
    
    % Filter negative frequencies out
    temp = 3;
%     for ff = 1 : nfreq
%         
%         if obs(ff,1) >= 0 || obs(ff,2) >= 0
%             
%             temp = temp + 1;
%             
%         elseif obs(ff,1) < 0 && obs(ff,2) < 0
%                        
%             continue
%             
%         end
%         
%     end
    
%     nfreq = temp;
    fprintf(fid, '%f  %f  %i\n', X(1) , Y(1), nfreq); 
             
    for ff = 1 : nfreq
                     
                        
        if tx(ff,5) == 1
            
            ot = 'x';
            
        elseif tx(ff,5) == 2
            
            ot = 'y';
            
        elseif tx(ff,5) == 3
            
            ot = 'z'; 
            
        end
        
        if rx(ff,5) == 1
            
            or = 'x';
            
        elseif rx(ff,5) == 2
            
            or = 'y';
            
        elseif rx(ff,5) == 3
            
            or = 'z'; 
            
        end        
        

%         if obs(ff,1) >= 0 && obs(ff,2) >= 0
            
%             argin = 'both';
            
%         elseif obs(ff,1) >= 0 && obs(ff,2) < 0
%             
%             argin = 'inphase';
%             
%         elseif obs(ff,2) >= 0 && obs(ff,1) < 0
%             
%             argin = 'quad';
%             
%         else
%             
%             continue
%             
%         end
        
        fprintf(fid, '%i  %i\n', freq(ff), 1);
        fprintf(fid, '%f  %f  %s  %i\n', tx(ff,4), tx(ff,3), ot, 1);
                
        if strcmp(octype{ff},'b')==1

            switch argin

                case 'inphase'

                    fprintf(fid, '%f  %f  %f  %f  %s  %i  %s  %12.4e %s %12.4e\n',...
                    rx(ff,4), tx(ff,1), tx(ff,2),...
                    rx(ff,3) ,or, ontype(ff), 'i',...
                    obs(ff,1),utype{ff},uncert(ff,1));


                case 'quad'

                    fprintf(fid, '%f  %f  %f  %f  %s  %i  %s  %12.4e %s %12.4e\n',...
                    rx(ff,4), tx(ff,1), tx(ff,2),...
                    rx(ff,3) ,or, ontype(ff), 'q',...
                    obs(ff,2),utype{ff},uncert(ff,2));

                case 'both'

                    fprintf(fid, '%f  %f  %f  %f  %s  %i  %s  %12.4e  %12.4e  %s  %12.4e  %12.4e\n',...
                            rx(ff,4), tx(ff,1), tx(ff,2),...
                            rx(ff,3) ,or, ontype(ff), octype{ff},...
                            obs(ff,1),obs(ff,2),utype{ff},uncert(ff,1),...
                            uncert(ff,2));

                otherwise

                    fprintf('Input argument should be inphase, quad or both\n');
                    break

            end

        else

            fprintf(fid, '%f  %f  %f  %f  %s  %i  %s  %12.4e  %s  %12.4e  \n',...
                    rx(ff,4), tx(ff,1), tx(ff,2),...
                    rx(ff,3) ,or, ontype(ff), octype{ff},...
                    obs(ff,1),utype{ff},uncert(ff,1));

        end
           
        
        
    end
    
    fclose(fid);
    
    % Create layer conductivity, susc and weights
    
    dz_layer = dz(Q(ii,3):end)';
    cond = m_con(Q(ii,3):end,Q(ii,1),Q(ii,2));
    cond_ref = m_con_ref(Q(ii,3):end,Q(ii,1),Q(ii,2));
    susc = m_sus(Q(ii,3):end,Q(ii,1),Q(ii,2));
    susc_ref = m_sus_ref(Q(ii,3):end,Q(ii,1),Q(ii,2));
    wght = w(Q(ii,3):end,Q(ii,1),Q(ii,2));
    
    ncells = length(dz_layer);
    
    % Check if phid has reached misfit, keep beta the same
    if phid(ii) <=target*6
        
%         m_con1D(:,Q(ii,1),Q(ii,2)) = m_con(:,Q(ii,1),Q(ii,2));
        beta(ii) = beta(ii);
%         d_pred = [[d_pred;[X Y Z freq pre uncert]]]; 
        fprintf('##\nStation %i has reached the target misfit\n##\n',ii)
        fprintf('##\nKeep current beta and re-invert\n##\n')
%         continue
    
    else
        
       beta(ii) = beta(ii)*cooling; 
        
    end
    
    fid1 = fopen([work_dir '\EM1D_conref.dat'],'w');
    fprintf(fid1,'%i\n',ncells+1);
    
    fid2 = fopen([work_dir '\EM1D_constart.dat'],'w');
    fprintf(fid2,'%i\n',ncells+1);
    
    fid3 = fopen([work_dir '\EM1D_susref.dat'],'w');
    fprintf(fid3,'%i\n',ncells+1);
    
    fid4 = fopen([work_dir '\EM1D_susstart.dat'],'w');
    fprintf(fid4,'%i\n',ncells+1);
    
    fid5 = fopen([work_dir '\w.dat'],'w');
    fprintf(fid5,'%i %i\n',1 , 0);
    fprintf(fid5,'%i\n',ncells+1);
    
    
    
    for jj = 1 : ncells
        
    % First iteration uses best halfspace
        if iter==1 && HSflag == 0

        fprintf(fid1,'%12.4f%12.4e\t\n',dz_layer(jj),cond_ref(jj));
            
        fprintf(fid2,'%12.4f\n',dz_layer(jj));
        
        fprintf(fid3,'%12.4f\t%12.8e\n',dz_layer(jj),susc_ref(jj));
        
        fprintf(fid4,'%12.4f\t%12.8e\n',dz_layer(jj),0);
        
        fprintf(fid5,'%12.4f%12.4e\t\n',dz_layer(jj),wght(jj));

        
        
        else

        fprintf(fid1,'%12.4f\t%12.8e\n',dz_layer(jj),cond_ref(jj));
        
        fprintf(fid2,'%12.4f\t%12.8e\n',dz_layer(jj),cond(jj));
        
        fprintf(fid3,'%12.4f\t%12.8e\n',dz_layer(jj),susc_ref(jj));
        
        fprintf(fid4,'%12.4f\t%12.8e\n',dz_layer(jj),susc(jj));

        fprintf(fid5,'%12.4f%12.4e\t\n',dz_layer(jj),wght(jj));
        
        end
        
    end
    
    if iter==1
        fprintf(fid1,'%12.4f\t%12.8e\n',0.0,cond_ref(jj));
        fprintf(fid2,'%12.4f\t%12.8e\n',0.0,cond(jj));
        fprintf(fid3,'%12.4f\t%12.8e\n',0.0,0);
        fprintf(fid4,'%12.4f\t%12.8e\n',0.0,0);
        fprintf(fid5,'%12.4f\t\n',0.0,wght(jj));
    else
        fprintf(fid1,'%12.4f\t%12.8e\n',0.0,cond_ref(jj));
        fprintf(fid2,'%12.4f\t%12.8e\n',0.0,cond(jj));
        fprintf(fid3,'%12.4f\t%12.8e\n',0.0,0);
        fprintf(fid4,'%12.4f\t%12.8e\n',0.0,susc(jj));
        fprintf(fid5,'%12.4f\t%12.8e\n',0.0,wght(jj));
    end
    fclose('all');
    %% Write input file
    fid = fopen([work_dir '\em1dfm.in'],'wt');
    
    fprintf(fid,'em1dfm ! rootnname\n');
    fprintf(fid,'Obs1D.dat  ! obs file name\n');
    fprintf(fid,'%i  ! type of model\n',mtype);
    fprintf(fid,'EM1D_constart.dat ! starting model\n');
    if mtype==3
        fprintf(fid,'EM1D_susstart.dat ! starting model\n');
    end
    fprintf(fid,'EM1D_conref.dat  ! ref (small) model\n');
    fprintf(fid,'EM1D_susref.dat  ! ref (small) model\n');
%     fprintf(fid,'DEFAULT  ! background sus model\n');
    fprintf(fid,'NONE  ! ref (flat) model\n');
    if mtype==3
        fprintf(fid,'NONE  ! ref (flat) model\n');
    end
    fprintf(fid,'NONE ! weights\n');
    if mtype==3
    fprintf(fid,'DEFAULT %6.4e  %6.4e %6.4e  %6.4e ! alphas\n',alpha_con(1),alpha_con(4),alpha_sus(1),alpha_sus(4));    
    else
    fprintf(fid,'%6.4e  %6.4e  ! alphas\n',alpha_con(1),alpha_con(4));
    end
    
    % Set beta parameters for current inversion
        
    fprintf(fid,'1  ! inv type\n');
    fprintf(fid,'%9.5e  ! inv parameters\n',beta(ii));
    fprintf(fid,'%i  ! max iteration\n',niter);

    if mtype==3
        fprintf(fid,'DEFAULT  ! log barrier term\n');
    end
    fprintf(fid,'DEFAULT  ! convergence test\n');
    fprintf(fid,'DEFAULT  ! number of Hankel kernel\n');
    fprintf(fid,'2  ! amount of output\n');
    
    fclose(fid);
    
    %% Run inversion and load model 
    cd(work_dir);
    fprintf('Sounding %i / %i\n',ii,nstn);
    [status,cmdout] = system('em1dfm.exe');

    cd(home_dir);

    %Load inverted conductivity
    mcon = load_EM1DFM_model(work_dir,'em1dfm.con');
    m_con1D(Q(ii,3):end,Q(ii,1),Q(ii,2)) = mcon(1:end-1);
    m_con1D(1:Q(ii,3),Q(ii,1),Q(ii,2)) = mcon(1);
    
    %Load inverted susceptibility or refmodel
    if mtype==3
        msus = load_EM1DFM_model(work_dir,'em1dfm.sus');
        m_sus1D(Q(ii,3):end,Q(ii,1),Q(ii,2)) = msus(1:end-1);
        m_sus1D(1:Q(ii,3),Q(ii,1),Q(ii,2)) = msus(1);
    
    else
        m_sus1D(Q(ii,3):end,Q(ii,1),Q(ii,2)) = susc_ref;
        
    end
        
    % Copy top cell all the way up the mesh to avoid 
    % interpolating air cells later
    
    
    
    % Read log file and extract 
    fid = fopen([work_dir '\em1dfm.out'],'r+');
    line = fgets(fid);
    while line~=-1
        
        temp = regexp(line,'Iteration','match');
        
        if isempty(temp) == 0
            
            invout      = regexp(line,'\d*\.?\d*','match');
            itern(ii)   = str2double(invout{1});
            phid(ii)    = str2double(invout{2});
            betafromfile    = str2num(invout{3});
            phim(ii)    = str2double(invout{4});
            phi(ii)     = str2double(invout{5});
            fprintf('         phid = %g, phim = %g, beta = %g\n',phid(ii),phim(ii),betafromfile);
            
        end
        
        temp = regexp(line,'Best-fitting','match');
        
        if isempty(temp) == 0
            invout      = regexp(line,'\d*\.?\d*','match');
            
            if isempty(regexp(line,'E-','match')) == 0
                
                bHSpace(:,Q(ii,1),Q(ii,2)) = str2double(invout{1})*10^(-str2double(invout{2}));
                
            else
                
                bHSpace(:,Q(ii,1),Q(ii,2)) = str2double(invout{1});
                
            end
                
        end
        
        line = fgets(fid);
        
    end
    
    m_misfit(:,Q(ii,1),Q(ii,2)) =  phid(ii);
    
    fclose(fid);
    
    % Load predicted and store
    pred = load_EM1DFM_obs(work_dir,'em1dfm.prd');
    
%     if size(pred{7}) ~= [3 2]
%         
%         fprintf('Say what!');
%         
%     end
    d_pred = [d_pred;[X Y Z freq pred{7} uncert]];
%     switch argin
%         case 'inphase'
%             d_pred{7}(logic,1) = pred{7};
%         case 'quad'
%             d_pred{7}(logic,2) = pred{7};
%         case 'both'
%             d_pred{7}(logic,:) = pred{7};
%             
%     end


    
end

% phid_avg = mean(phid);
m_con1D = reshape(m_con1D,nz*nx*ny,1);
m_sus1D = reshape(m_sus1D,nz*nx*ny,1);
m_misfit = reshape(m_misfit,nz*nx*ny,1);
bHSpace  = reshape(bHSpace,nz*nx*ny,1);
% save([work_dir '\Inv_model3D.con'],'-ascii','m_inv3D')




