function [P,W] = make_EM1D_P_3D(work_dir,meshfile,Q,interp_n,interp_r,ax,ay)
% Function make_1D_P_3D
% Create interpolator (P) matrix to transfer 1D column models 
% onto 3D mesh using a distance weighted average scheme
%
% INPUT
% work_dir  : directory of files
% meshfile  : Mesh file in UBC format
% Q         : Querry matrix generated by function "make_EM1DFM_Q_3D.m"
% nnodes    : Number of observation points to be used for the averaging
%
% SUB-FUNCTION CALLS
% get_UBC_mesh.m    : Load mesh file and output [5xn] matrix

%% SCRIPT STARTS HERE

%% Load mesh
[xn,yn,zn]=read_UBC_mesh([work_dir '\' meshfile]);
nx = length(xn)-1; %size(X,1);    %number of cell in X
ny = length(yn)-1; %size(X,2);    %number of cell in Y
nz = length(zn)-1; %size(X,3);    %number of cell in Z

% Create 3D cell center array
xc = (xn(1:end-1) + xn(2:end) ) /2;
yc = (yn(1:end-1) + yn(2:end) ) /2;

mcell = nx*ny*nz;

%% Create array of points from Q matrix
nsnds = size(Q,1); % Number of soundings

obsx = zeros(nsnds,1);
obsy = zeros(nsnds,1);

for ii = 1 : nsnds

    obsx(ii) = xc(Q(ii,1));
    obsy(ii) = yc(Q(ii,2));
    
end

%% Create Projector and Querry matrices
% Cycles to all the cells in 2D and find closest observation points from
% which information will be taken after inversion. The weights are
% calculate for a = 1/r such that:
% m = (a1*x1 + a2*x2) / (a1 + a2)
W = zeros(mcell,interp_n);%spalloc(mcell,mcell,nnodes*mcell);
P = zeros(mcell,interp_n);
% indx = [];
keep = zeros(nx*ny,1);
count = 1;
progress = 0;
tic
dr =  interp_r/interp_n; 
% P = zeros(
count = 0;
zblock = kron(ones(1,interp_n),(1:nz)');

for jj = 1 : ny

    for ii = 1 : nx

        count = count + 1;
        
        r = ( ( (xc(ii) - obsx(:)) / ax ).^2 +...
                ( (yc(jj) - obsy(:)) / ay ).^2 ) .^ 0.5;


        % Compute inverse distance + small number to avoid singularity
        r = 1./(r+dr);

        % Sort points by distance and keep n smallest
        [rsort,index] = sort(r,'descend');

        % Compute weighted average
        denom = sum(rsort(1:interp_n));

        % Assign weights to the right nodes
        numer = zeros(1,interp_n); 
        temp = zeros(1,nx*ny);
        
        % Treshold the distance
        if max(rsort) > 1/interp_r;
%             for qq = 1 : interp_n
% 
%                 numer(qq) = rsort(qq)/denom;
%                 temp(index(qq)) = 1;
%                 
%             end
           indx = (1:nz) + ( nx*(jj-1)+(ii-1) ) * nz;
           
           p = (nx*(Q(index(1:interp_n),2)-1) + (Q(index(1:interp_n),1)-1)) * nz;
           P(indx,:) = zblock + kron(p',ones(nz,1));
           W(indx,:) = kron(ones(nz,1), rsort(1:interp_n)'/denom);
%            indx(count,:) = temp==1;
%            keep(count) = 1;
           
        end
        
%         numer = reshape(numer,1,nx*ny);

        % Create weight matrix for current column of model
%         w = kron(numer,speye(nz))     

        % Prompt iteration and time message
        d_iter = floor(ii*jj/(nx*ny)*20);

        if  d_iter > progress

            fprintf('Computed %i pct of data in %8.5f sec\n',d_iter*5,toc)

            progress = d_iter;        
            tic

        end
            
    end

end


